% function contact_number
% contact_number takes the features file generated by trackpy as an input.
%
% For each particle, it counts the number of other particles in
% contact/bonded with it (within the range defined by contactRange,
% traditionally the first minimum of g(r)).
%
% Saves the number of contacts for each particle to a new file with all of
% the original features info from trackpy. Also generates the distribution
% of the number of particles in contact.
%
% The second part of the file compares the contact number distribution for
% different height ranges.


% Max range to be counted as in contact (in microns)
contactRange = 2.8;

folder = 'E:\Xerox Data\30um gap runs 2016\0.5Hz 0.1V 9-12-16.mdb';

numfiles = 9;

% Can use a list of the file numbers if one is missing, etc.
fileNumbers = 1:1:numfiles;
% fileNumbers = [1 2 4 5 6 7 8 9];

% Declare cell array sizes.
filename = cell(numfiles,1);
for fnum = fileNumbers %1:1:numfiles
    filename{fnum} = [folder '\ts' num2str(fnum) '_static_bpass_3D_static_160\ts' num2str(fnum) '_features.csv'];

% filein = 'E:\ts5_bpass_normalized_static_160\ts5_features.csv';
filein = filename{fnum};
fileout_dist = [filein(1:length(filein) - 4), '_contact_dist.csv'];
fileout_w_contacts= [filein(1:length(filein)-4), '_w_contacts.csv'];
% filein = ['G:\BackUp_Colloids_Data\XEROX\2016_02_23.mdb\' num2str(pcnt) '_immediate_2enhanced_bp4_feature.csv'];
% fileout = ['G:\BackUp_Colloids_Data\XEROX\2016_02_23.mdb\' num2str(pcnt) '_immediate_2enhanced_bp4_g_r.csv'];
data=xlsread(filein);

% rc = 6; %calculation range (Microns)
% dr= 0.1; %radius step (microns)
% % grc=zeros(rc/dr,2); %declare output data(radius,g(r))



% Load x, y, z data and convert distances into um.
data(:,2)=data(:,2)*(0.127);
data(:,3)=data(:,3)*(0.127);
data(:,4)=data(:,4)*(0.135);

xmin = min(data(:,2));
ymin = min(data(:,3));
zmin = min(data(:,4));

xmax=max(data(:,2));
ymax=max(data(:,3));
zmax=max(data(:,4));

% Don't really need to isolate the center part for contact number.
% % Take only data near center for calculation. May want to increase size of
% % center to reduce noise? Could also skew data though by reducing number of
% % far away particles (if you go off the edge of the image).
% % Why divide by 8 specifically? Why not include z column in calculations?
% aNumber = 2;
% center=data(data(:,2) > rc/aNumber & data(:,2) < xmax-rc/aNumber & data(:,3) > rc/aNumber & data(:,3) < ymax -rc/aNumber & data(:,4) > rc/aNumber & data(:,4) < zmax -rc/aNumber,2:4);
% % center = data(:, 1:3);
% center=sortrows(center,3); % Sort center data by z height.

% % Array of only positions. Don't really need it but it's convenient.
% positions = data(:,2:4);

contacts = zeros(length(data), 1); % Declare an array 
maxContacts = 12;
contactDist_total=zeros(maxContacts+1,2);%declare the contact number  distribution array
contactDist_total(:,1) = 0:1:maxContacts;
% Could probably do all the distribution stuff at the end using the
% contacts array anyway.

for i=1:1:length(data)
    %calculate the relative position vector. (Calculate for every other
    %particle in one step with repmat)
    % repmat takes one row of the center matrix and repeats it for each other
    % row to make it the size of data. Then subtract to have distances.
    shifted_vector=data(:,2:4)-repmat(data(i,2:4),length(data),1);
    shifted_vector=abs(shifted_vector); %take the absolute value.
%     % Limit to selected max range rc.
%     shifted_vector=shifted_vector( shifted_vector(:,1)<rc & shifted_vector(:,2)<rc & shifted_vector(:,3)<rc,:);
    distance=zeros(length(shifted_vector),1);

    % Counter variable for the number of particles in contact.
    contactCount = 0;
    
    for j=1:1:length(shifted_vector)
        distance(j,1)=norm(shifted_vector(j,1:3));
        if distance(j,1) < contactRange && distance(j,1) ~= 0
            contactCount = contactCount + 1;
        end
    end
    
    contacts(i) = contactCount;

    if mod(i,1000)==0
        fprintf([num2str(i) '/' num2str(length(data)) '\n']);
    end

end

% Create contact number distribution
for i = 1:1:length(contacts)-1
    contactDist_total(contacts(i)+1,2) = contactDist_total(contacts(i)+1,2) + 1;
end

% Get mean contact number
meanContacts_total = 0;
for i = 1:1:maxContacts+1
    meanContacts_total = meanContacts_total + contactDist_total(i,1)*contactDist_total(i,2);
end
meanContacts_total = meanContacts_total / sum(contactDist_total(:,2));
    
% Save the contact number to the data file
ext_data = [data, contacts];

% figure;
% plot(contactDist_total(:,1), contactDist_total(:, 2), 'b:o');
% title('Contact Number Distribution');
% xlabel('Contacts');
% ylabel('Number');

% Calculate contact number distribution with buffer on all 6 sides
xybuffer = 3; % Buffer region from outer particle for x and y (in um)
zbuffer = 3; % Buffer region for z (in um)

selection =ext_data(ext_data(:,2) > xmin + xybuffer & ext_data(:,2) < xmax-xybuffer &...
    ext_data(:,3) > ymin + xybuffer & ext_data(:,3) < ymax - xybuffer &...
    ext_data(:,4) > zmin & ext_data(:,4) < zmax, [2:4 16:16]);

contactDist_withBuffer = zeros(maxContacts+1,2);
contactDist_withBuffer(:,1) = 0:1:maxContacts;

% Create contact number distribution
for i = 1:1:length(selection)-1
    contactDist_withBuffer(selection(i,4)+1,2) = contactDist_withBuffer(selection(i,4)+1,2) + 1;
end

% Get mean contact number
meanContacts_withBuffer = 0;
for i = 1:1:maxContacts+1
    meanContacts_withBuffer = meanContacts_withBuffer + contactDist_withBuffer(i,1)*contactDist_withBuffer(i,2);
end
meanContacts_withBuffer = meanContacts_withBuffer / sum(contactDist_withBuffer(:,2));

figure;
hold on
plot(contactDist_withBuffer(:,1), contactDist_withBuffer(:, 2), 'b:o');
title('Contact Number Distribution');
xlabel('Contacts');
ylabel('Number');
hold off

% % Compare distributions with and without buffer
% figure;
% hold on
% plot(contactDist_withBuffer(:,1), contactDist_withBuffer(:, 2)/sum(contactDist_withBuffer(:,2)), 'b:o');
% plot(contactDist_total(:,1), contactDist_total(:, 2)/sum(contactDist_total(:,2)), 'r:o');
% title('Contact Number Distribution');
% xlabel('Contacts');
% ylabel('Number');
% hold off

csvwrite(fileout_dist, contactDist_withBuffer);
csvwrite(fileout_w_contacts, ext_data);

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Calculate contact number by height
% 
% xybuffer = 3; % Buffer region from outer particle for x and y (in um)
% zbuffer = 3; % Buffer region for z (in um)
% interval = 2; % Interval for measuring contact distribution by height (in um)
% heightSet = (zmin + zbuffer):interval:(zmax-zmin-zbuffer);
% % Define contactDist cell array
% contactDist = cell(length(heightSet),1);
% meanContacts = zeros(length(heightSet),1);
% count = 1;
% for height = heightSet
%     zbot = height;
%     ztop = height + interval;
%     % Limit zrange and x and y positions far from walls.
%     % Select only xyz position data and calculated number of neighbors.
%     selection =ext_data(ext_data(:,2) > xmin + xybuffer & ext_data(:,2) < xmax-xybuffer &...
%         ext_data(:,3) > ymin + xybuffer & ext_data(:,3) < ymax - xybuffer &...
%         ext_data(:,4) > zbot & ext_data(:,4) < ztop, [2:4 16:16]);
%     %focus=sortrows(focus,4); % Sort center data by z height. I don't know why
%     %i would need that particularly though
% 
%     contactDist{count}=zeros(maxContacts+1,2);%declare the contact number  distribution array
%     contactDist{count}(:,1) = 0:1:maxContacts;
% 
%     for i = 1:1:length(selection)-1
%         contactDist{count}(selection(i,4)+1,2) = contactDist{count}(selection(i,4)+1,2) + 1;
%     end
%     count = count + 1;
% end
% 
% % Calculate mean contact number
% for i = 1:1:count-1
%     for j = 1:1:maxContacts+1
%         meanContacts(i) = meanContacts(i) + contactDist{i}(j,1)*contactDist{i}(j,2);
%     end
%     meanContacts(i) = meanContacts(i) / sum(contactDist{i}(:,2));
% end
% 
% plotStyle = ':o';
% % plotStyle = {'b:o', 'c:o', 'r:o', 'g:o', 'm:o', 'k:o', 'y:o'};
% 
% colorList = {[0 0 0], [0 0 1], [0 1 0], [0 1 1], [1 0 0], [1 0 1], ...%[1 1 0],...
%     [0.9412 0.4706 0], [0.251 0 0.502], [0.502 0.251 0], [0 0.251 0],...
%     [0.502 0.502 0.502], [0.502 0.502 1], [0 0.502 0.502], [0.502 0 0], [1 0.502 0.502]};
% 
% figure;
% hold on
% 
% for i = 1:1:length(contactDist)
%     plot(contactDist{i}(:,1), contactDist{i}(:,2)/sum(contactDist{i}(:,2)), plotStyle, 'Color', colorList{i});
%     legendInfo{i} = ['contactDist ' num2str(i)];
% end
% title('Contact Number Distribution');
% xlabel('Contacts');
% ylabel('Probability');
% legend(legendInfo);
% plot(contactDist_withBuffer(:,1), contactDist_withBuffer(:, 2)/sum(contactDist_withBuffer(:,2)), 'b-o');
% hold off


end
% end